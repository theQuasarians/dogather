!function(){var e={};Object.defineProperty(e,"__esModule",{value:!0});var t={};Object.defineProperty(t,"__esModule",{value:!0});var n,s={},r="object"==typeof Reflect?Reflect:null,o=r&&"function"==typeof r.apply?r.apply:function(e,t,n){return Function.prototype.apply.call(e,t,n)};n=r&&"function"==typeof r.ownKeys?r.ownKeys:Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function(e){return Object.getOwnPropertyNames(e)};var i=Number.isNaN||function(e){return e!=e};function a(){a.init.call(this)}var c=function(e,t){return new Promise((function(n,s){function r(){void 0!==o&&e.removeListener("error",o),n([].slice.call(arguments))}var o;"error"!==t&&(o=function(n){e.removeListener(t,r),s(n)},e.once("error",o)),e.once(t,r)}))};(s=a).once=c,a.EventEmitter=a,a.prototype._events=void 0,a.prototype._eventsCount=0,a.prototype._maxListeners=void 0;var d=10;function l(e){if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e)}function p(e){return void 0===e._maxListeners?a.defaultMaxListeners:e._maxListeners}function u(e,t,n,s){var r,o,i,a;if(l(n),void 0===(o=e._events)?(o=e._events=Object.create(null),e._eventsCount=0):(void 0!==o.newListener&&(e.emit("newListener",t,n.listener?n.listener:n),o=e._events),i=o[t]),void 0===i)i=o[t]=n,++e._eventsCount;else if("function"==typeof i?i=o[t]=s?[n,i]:[i,n]:s?i.unshift(n):i.push(n),(r=p(e))>0&&i.length>r&&!i.warned){i.warned=!0;var c=new Error("Possible EventEmitter memory leak detected. "+i.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");c.name="MaxListenersExceededWarning",c.emitter=e,c.type=t,c.count=i.length,a=c,console&&console.warn&&console.warn(a)}return e}function m(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function h(e,t,n){var s={fired:!1,wrapFn:void 0,target:e,type:t,listener:n},r=m.bind(s);return r.listener=n,s.wrapFn=r,r}function f(e,t,n){var s=e._events;if(void 0===s)return[];var r=s[t];return void 0===r?[]:"function"==typeof r?n?[r.listener||r]:[r]:n?function(e){for(var t=new Array(e.length),n=0;n<t.length;++n)t[n]=e[n].listener||e[n];return t}(r):v(r,r.length)}function g(e){var t=this._events;if(void 0!==t){var n=t[e];if("function"==typeof n)return 1;if(void 0!==n)return n.length}return 0}function v(e,t){for(var n=new Array(t),s=0;s<t;++s)n[s]=e[s];return n}Object.defineProperty(a,"defaultMaxListeners",{enumerable:!0,get:function(){return d},set:function(e){if("number"!=typeof e||e<0||i(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");d=e}}),a.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},a.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||i(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},a.prototype.getMaxListeners=function(){return p(this)},a.prototype.emit=function(e){for(var t=[],n=1;n<arguments.length;n++)t.push(arguments[n]);var s="error"===e,r=this._events;if(void 0!==r)s=s&&void 0===r.error;else if(!s)return!1;if(s){var i;if(t.length>0&&(i=t[0]),i instanceof Error)throw i;var a=new Error("Unhandled error."+(i?" ("+i.message+")":""));throw a.context=i,a}var c=r[e];if(void 0===c)return!1;if("function"==typeof c)o(c,this,t);else{var d=c.length,l=v(c,d);for(n=0;n<d;++n)o(l[n],this,t)}return!0},a.prototype.addListener=function(e,t){return u(this,e,t,!1)},a.prototype.on=a.prototype.addListener,a.prototype.prependListener=function(e,t){return u(this,e,t,!0)},a.prototype.once=function(e,t){return l(t),this.on(e,h(this,e,t)),this},a.prototype.prependOnceListener=function(e,t){return l(t),this.prependListener(e,h(this,e,t)),this},a.prototype.removeListener=function(e,t){var n,s,r,o,i;if(l(t),void 0===(s=this._events))return this;if(void 0===(n=s[e]))return this;if(n===t||n.listener===t)0==--this._eventsCount?this._events=Object.create(null):(delete s[e],s.removeListener&&this.emit("removeListener",e,n.listener||t));else if("function"!=typeof n){for(r=-1,o=n.length-1;o>=0;o--)if(n[o]===t||n[o].listener===t){i=n[o].listener,r=o;break}if(r<0)return this;0===r?n.shift():function(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}(n,r),1===n.length&&(s[e]=n[0]),void 0!==s.removeListener&&this.emit("removeListener",e,i||t)}return this},a.prototype.off=a.prototype.removeListener,a.prototype.removeAllListeners=function(e){var t,n,s;if(void 0===(n=this._events))return this;if(void 0===n.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==n[e]&&(0==--this._eventsCount?this._events=Object.create(null):delete n[e]),this;if(0===arguments.length){var r,o=Object.keys(n);for(s=0;s<o.length;++s)"removeListener"!==(r=o[s])&&this.removeAllListeners(r);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(t=n[e]))this.removeListener(e,t);else if(void 0!==t)for(s=t.length-1;s>=0;s--)this.removeListener(e,t[s]);return this},a.prototype.listeners=function(e){return f(this,e,!0)},a.prototype.rawListeners=function(e){return f(this,e,!1)},a.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):g.call(e,t)},a.prototype.listenerCount=g,a.prototype.eventNames=function(){return this._eventsCount>0?n(this._events):[]};var w={};Object.defineProperty(w,"__esModule",{value:!0});var y={};Object.defineProperty(y,"__esModule",{value:!0});var _=class{constructor(e){this._name=e}get name(){return this._name}get path(){return console.warn("'sender.path' is now deprecated, since it no longer supports iframes. Use 'sender.name' instead"),this._name}isInternal(){return this.isInternalImpl(!1)}isReallyInternal(){return console.warn("'sender.isReallyInternal()' is now deprecated, since it no longer supports iframes. Use 'sender.isInternal()' instead"),this.isInternalImpl(!0)}toString(){return this._name}isInternalImpl(e){return!e&&0===this._name.indexOf("devtools")||!/window|frame/.test(this._name)}};y.Endpoint=_;var b={};Object.defineProperty(b,"__esModule",{value:!0});var x=function(){return"oooooo".replace(/[o]/g,e=>(e^crypto.getRandomValues(new Uint8Array(1))[0]&15>>e/4).toString(16))};b.uuid=x;var M,L,C;M=function(e){return"object"==typeof e?function e(t,n){var s;s=Array.isArray(t)?[]:{};n.push(t),Object.keys(t).forEach((function(r){var o=t[r];"function"!=typeof o&&(o&&"object"==typeof o?-1!==n.indexOf(t[r])?s[r]="[Circular]":s[r]=e(t[r],n.slice(0)):s[r]=o)})),"string"==typeof t.name&&(s.name=t.name);"string"==typeof t.message&&(s.message=t.message);"string"==typeof t.stack&&(s.stack=t.stack);return s}(e,[]):"function"==typeof e?"[Function: "+(e.name||"anonymous")+"]":e},(C=L||(L={}))[C.Window=0]="Window",C[C.Frame=1]="Frame",C[C.Devtools=2]="Devtools",C[C.Background=3]="Background",C[C.ContentScript=4]="ContentScript",C[C.Worker=5]="Worker";const S=/^((?:background$)|devtools|content-script|window)(?:@(\d+))?$/,E=e=>"undefined"!=typeof chrome&&chrome[e];class I{static sendMessage(e,t,n){let s=n instanceof y.Endpoint?n.name:n;const r="Bridge#sendMessage ->";if(!S.test(s))throw new TypeError(r+" Destination must be any one of known destinations");if(this.context===L.Background){const[e,t,n]=s.match(S);if("background"!==t&&!n||!parseInt(n,10))throw new TypeError(r+" When sending messages from background page, use @tabId syntax to target specific tab")}return new Promise((n,r)=>{const o={messageID:e,data:t,destination:s,messageType:"message",transactionId:b.uuid(),origin:this.ctxname,hops:[],timestamp:Date.now()};this.openTransactions.set(o.transactionId,{resolve:n,reject:r}),this.routeMessage(o)})}static onMessage(e,t){this.onMessageListeners.set(e,t)}static init(){if(!this.isInitialized){if(null===this.context)throw new Error("Unable to detect runtime context i.e crx-bridge can't figure out what to do");if(this.id=b.uuid(),this.ctxname=L[this.context].toLowerCase(),this.context!==L.Window&&this.context!==L.ContentScript||window.addEventListener("message",this.handleWindowOnMessage),this.context===L.ContentScript&&(this.ctxname="content-script"),this.context===L.Devtools){const e="devtools@"+chrome.devtools.inspectedWindow.tabId;this.ctxname=e,this.port=chrome.runtime.connect({name:e}),this.port.onMessage.addListener(e=>{this.routeMessage(e)}),this.port.onDisconnect.addListener(()=>{this.port=null})}this.context===L.Background&&chrome.runtime.onConnect.addListener(e=>{const t=""!==e.name?e.name:"content-script@"+e.sender.tab.id;this.portMap.set(t,e),this.messageQueue.forEach(n=>{n.resolvedNextNode===t&&(e.postMessage(n.message),this.messageQueue.delete(n))}),e.onDisconnect.addListener(()=>{this.portMap.delete(t)}),e.onMessage.addListener(t=>{this.routeMessage(t,{sourcePort:e})})}),this.context===L.ContentScript&&top===window&&(this.port=chrome.runtime.connect(),this.port.onMessage.addListener(e=>{this.routeMessage(e)})),this.isInitialized=!0}}static async handleInboundMessage(e){const{transactionId:t,messageID:n,messageType:s}=e;if("reply"===s){const n=I.openTransactions.get(t);if(n){const{err:s,data:r}=e;if(s){const e=new("function"==typeof self[s.name]?self[s.name]:Error)(s.message);for(let t in s)e[t]=s[t];n.reject(e)}else n.resolve(r);I.openTransactions.delete(t)}}else if("message"===s){let t,s,r=!1;try{const o=I.onMessageListeners.get(n);if("function"!=typeof o)throw r=!0,new Error(`[crx-bridge] No handler registered in '${I.ctxname}' to accept messages with id '${n}'`);t=await o({sender:new y.Endpoint(e.origin),id:n,data:e.data,timestamp:e.timestamp})}catch(e){s=e}finally{if(s&&(e.err=M(s)),I.routeMessage({...e,messageType:"reply",data:t,origin:I.ctxname,destination:e.origin,hops:[]}),s&&!r)throw t}}}static winRouteMsg(e,t){I.ensureNamespace();const n=new MessageChannel,s=setTimeout(()=>{n.port1.onmessage=null,I.winRouteMsg(e,t)},300);n.port1.onmessage=n=>{clearTimeout(s),e.postMessage({cmd:"__crx_bridge_route_message",scope:I.namespace,payload:t,context:I.context},"*")},e.postMessage({cmd:"__crx_bridge_verify_listening",scope:I.namespace,context:I.context},"*",[n.port2])}}I.ctxname=null,I.id=null,I.context=E("devtools")?L.Devtools:E("tabs")?L.Background:E("extension")?L.ContentScript:"undefined"==typeof document&&"function"==typeof importScripts?L.Worker:"undefined"!=typeof document&&window.top!==window?L.Frame:"undefined"!=typeof document?L.Window:null,I.isExternalMessagingEnabled=!1,I.linkedNodesCache={},I.isInitialized=!1,I.openTransactions=new Map,I.onMessageListeners=new Map,I.port=null,I.portMap=new Map,I.messageQueue=new Set,I.setNamespace=e=>{I.namespace=e},I.allowWindowMessaging=e=>{I.isWindowMessagingAllowed=!0,I.namespace=e},I.handleWindowOnMessage=async e=>{if(I.context===L.ContentScript&&!I.isWindowMessagingAllowed)return;const{data:t,source:n,ports:s}=e;if("__crx_bridge_verify_listening"!==t.cmd||t.scope!==I.namespace||t.context===I.context)"__crx_bridge_route_message"===t.cmd&&t.scope===I.namespace&&t.context!==I.context&&(I.context===L.ContentScript&&(t.payload.origin="window"),I.routeMessage(t.payload));else{s[0].postMessage(!0)}},I.routeMessage=async(e,t={})=>{const{origin:n,messageID:s,transactionId:r,destination:o}=e;if(!(e.hops.indexOf(I.id)>-1)&&(e.hops.push(I.id),(I.context!==L.ContentScript||!/window/.test(e.destination+n)||I.allowWindowMessaging)&&(o||I.handleInboundMessage(e),S.test(o)))){if(I.context===L.Frame)throw new Error("crx-bridge no longer supports iframes due to too much complexity and not so many use cases");if(I.context===L.Window)I.winRouteMsg(window,e);else if(I.context===L.ContentScript&&"window"===o)e.destination=null,I.winRouteMsg(window,e);else if(I.context===L.Devtools||I.context===L.ContentScript)/background/.test(o)&&(e.destination=null),I.port.postMessage(e);else if(I.context===L.Background&&t.sourcePort){const[s,r,i]=o.match(S),[a,c,d=""+t.sourcePort.sender.tab.id]=n.match(S);/content-script|window/.test(c)&&(e.origin=`${c}@${d}`);const l=i?s:`${s}@${d}`;e.destination="window"!==r?null:"window";const p="window"===r?l.replace("window","content-script"):l,u=I.portMap.get(p);u?u.postMessage(e):I.messageQueue.add({resolvedNextNode:p,message:e})}}},I.ensureNamespace=()=>{if("string"!=typeof I.namespace||0===I.namespace.length){throw new Error("crx-bridge uses window.postMessage to talk with other \"window\"(s), for message routing and stuff, which is global/conflicting operation in case there are other scripts using crx-bridge. Call Bridge#setNamespace(nsps) to isolate your app. Example: Bridge.setNamespace('com.facebook.react-devtools'). Make sure to use same namespace across all your scripts whereever window.postMessage is likely to be used")}};var O=I;w.Bridge=O,I.init();var k={};Object.defineProperty(k,"__esModule",{value:!0});class j{constructor(e){this.handleStreamClose=()=>{this.isClosed||(this.isClosed=!0,this.emitter.emit("closed",!0),this.emitter.removeAllListeners())},"string"==typeof e.endpoint&&(e.endpoint=new y.Endpoint(e.endpoint)),this.internalInfo=e,this.emitter=new s.EventEmitter,this.isClosed=!1,j.initDone||(w.Bridge.onMessage("__crx_bridge_stream_transfer__",e=>{const{streamId:t,streamTransfer:n,action:s}=e.data,r=j.openStreams.get(t);r&&!r.isClosed&&("transfer"===s&&r.emitter.emit("message",n),"close"===s&&(j.openStreams.delete(t),r.handleStreamClose()))}),j.initDone=!0),j.openStreams.set(e.streamId,this)}get info(){return this.internalInfo}send(e){if(this.isClosed)throw new Error("Attempting to send a message over closed stream. Use stream.onClose(<callback>) to keep an eye on stream status");w.Bridge.sendMessage("__crx_bridge_stream_transfer__",{streamId:this.internalInfo.streamId,streamTransfer:e,action:"transfer"},this.internalInfo.endpoint)}close(e){e&&this.send(e),this.handleStreamClose(),w.Bridge.sendMessage("__crx_bridge_stream_transfer__",{streamId:this.internalInfo.streamId,streamTransfer:null,action:"close"},this.internalInfo.endpoint)}onMessage(e){return this.getDisposable("message",e)}onClose(e){return this.getDisposable("closed",e)}getDisposable(e,t){this.emitter.on(e,t);const n=()=>{this.emitter.removeListener(e,t)};return Object.assign(n,{dispose:n,close:n})}}j.initDone=!1,j.openStreams=new Map;var P=j;k.Stream=P;class T extends w.Bridge{static init(){super.init(),this.onMessage("__crx_bridge_stream_open__",e=>new Promise(t=>{const{sender:n,data:s}=e,{channel:r}=s;let o=!1;const i=()=>{const e=this.onOpenStreamCallbacks.get(r);"function"==typeof e?(e(new k.Stream({...s,endpoint:n})),o&&this.streamyEmitter.removeListener("did-change-stream-callbacks",i),t(!0)):o||(o=!0,this.streamyEmitter.on("did-change-stream-callbacks",i))};i()}))}static onOpenStreamChannel(e,t){if(this.onOpenStreamCallbacks.has(e))throw new Error("crx-bridge: This channel has already been claimed. Stream allows only one-on-one communication");this.onOpenStreamCallbacks.set(e,t),this.streamyEmitter.emit("did-change-stream-callbacks")}static async openStream(e,t){if(this.openStreams.has(e))throw new Error("crx-bridge: A Stream is already open at this channel");const n={streamId:b.uuid(),channel:e,endpoint:t},s=new k.Stream(n);return s.onClose(()=>{this.openStreams.delete(e)}),await this.sendMessage("__crx_bridge_stream_open__",n,t),this.openStreams.set(e,s),s}}T.openStreams=new Map,T.onOpenStreamCallbacks=new Map,T.streamyEmitter=new s.EventEmitter;var D=T;t.BridgePlus=D,T.init();var N=k.Stream;e.Stream=N;var W=y.Endpoint;e.Endpoint=W;var B=t.BridgePlus;e.default=B}();